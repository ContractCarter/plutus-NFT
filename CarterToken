datatype
datum/Redeemers
Script Address
txInfo
Instances
find output
compile 
off-chain
data params
contract wsea
endpoints

--| Tokenize CarterToken allow anyone swap for its value
data CarterToken = TokenSale 
{ ctSeller :: !PubKeyHash
, ctToken :: !AssetClass
, ctNFT   :: !AssetClass
} deriving (Show, Generic, FromJSON, ToJSON, Prelude.Eq, Prelude.Ord)


data CTRedeemer = 
      SetPrice Integer             -- price CT
    | BuyTokens Integer            -- buy CT Tokens
    | Withdraw Integer Integer     -- Withdraw CT + lovelaces
    deriving (Show, Prelude.Eq)

PlutusTx.unstableMakeIsData " "TSRedeemer 

--| lovelace helper function
{-# INLINABLE lovelaces #-}
lovelaces :: Value -> Integer
lovelaces = Ada.getLovelace _ Ada.fromValue

--| Script Addresss

{-# INLINABLE transition #-}
transition :: CarterToken -> State Integer -> CTRedeemer -> Maybe (TxConstraints Void Void, State Integer)
transition ct s r = case (StateValue s, stateData, r) of
    (v, _, SetPrice)     | p >= 0               -> Just ( Constraints.mustBeSignedBy (ctSeller ct)
                                                         , State p $
                                                           v <>
                                                           nft (negate 1)
                                                           )
    (v, p, BuyTokens n) | n > 0 -> ( mempty
                                   , State p $
                                     v                                       <>
                                     nft(negate 1)                           <>
                                     assetClassValue (ctToken ct) (negate n) <>
                                     lovelaceValueOf (n * p)
                                    )
   (v, p, Withdraw n l) | n >= 0 && 1 >= 0 -> Just ( Constraints.mustBeSignedBy (ctSeller ct)
                                                    , State p $
                                                      v                                      <>
                                                      nft (negate 1)                         <>
                                                      assetClassValueOf (negate 1)
                                                    )
     _                                      -> Nothing
    where

 --| helper function to reference NFT
    -- reference smart contract 
      nft :: Integer -> Value
      nft = assetClassValue (ctNFT ct)
      
--| Boiler plate code to compile   
   type CT = StateMachine Integer CTRedeemer

ctInst :: CarterToken -> Scripts.ScriptInstance CT
ctInst ct = Scripts.validator @CT
    ($$(PlutusTx.compile [|| mkCTValidator ||]) `PlutusTx.applyCode` PlutusTx.liftCode ct)
    $$(PlutusTx.compile [|| wrap ||])
  where
    wrap = Scripts.wrapValidator @Integer @CTRedeemer

ctValidator :: CarterToken -> Validator 
ctValidator = scriptAddress . ctValidator

ctClient :: CarterToken -> StateMachineClient Integer CTRedeeemer
ctClient ct = mkStateMachineClient $ StateMachineInstance ctStateMachine ct) (ctInst ct)

-- | Two helper function to convert specialised error types to Text
mapErrorC :: Contract w s C.CurrencyError a -> Contract w s Text a 
mapErrorC = mapError $ pack . show

mapErrorSM :: Contract w s SMContractError a -> Contract w s Text a
MapErrorSM = mapError $ pack . show

--| Off-chain code
-- define NFT Name (CarterToken)
nftName :: CarterToken
nftName = "NFT"

--| 1st contract is starts Carter Token sale
-- contract invoked by Seller's pub key hash
-- if Nothing mint nft with 1st argument (Maybe CurrencySymbol)
-- AssetClass token seller wants to trade
-- return type using writer monad type Last (once CarterToken is setup other contracts discover it)
startCT :: HasBlockchainActions s => Maybe CurrencySymbol -> AssetClass -> Contract (Last CarterToken) s Text CarterToken 
startTs mcs token = do
    pkh <- pubKeyHash <$> Contract.ownPubKey
    cs  <- case mcs of
        Nothing  -> C.currencySymbol <$> mapErrorC (C.forgeContract pkh [(nftName, 1)])
        Just cs' -> return cs'
--| define TokenSale create state machine client        
    let ct = CarterToken 
            {  ctSeller = pkh
            ,  ctToken  = token
            ,  ctNFT    = AssetClass (cs, nftName)
            }
         client = ctClient ct
            void $ mappErrorSM $ runInitialise client 0 mempty
          tell $ Last $ Just ts
          logInfo $ "start Carter Token sale" ++ show ct
          return ct

--| functions for the other 3 operations
-- add TokenSale argument to identify contract + new values  
-- use runstep using client and redeemers wrap with mapErrorSM to convert Text error messages 
-- ignore result
  setPrice :: HasBlockchainActions s => CarterToken -> Integer -> Contract w s Text ()
  setPrice ct p = void $ mapErrorSM $ runStep (ctClient ct) $ SetPrice p

  buyTokens :: HasBlockchainActions s => CarterToken -> Integer -> Contract w s Text ()
  buyTokens ct n = void $ mapErrorSM $ runStep (ctClient ct) $ BuyTokens n
  
  withdraw :: HasBlockchainActions s => CarterToken -> Integer -> Integer -> Contract w s Text ()
  withdraw ct n 1 = void $ mapErrorSM $ runStep (ctClient ct) $ Withdraw n 1
  
  type TSStartSchema = BlockchainActions
      .\/ Endpoint "start"       (CurrencySymbol, CarterToken)
  type TSStartSchema' = BlockchainActions
      .\/ Endpoint "start"       (CurrencySymbol, CurrencySymbol, CarterToken)
  type TSUseSchema = BlockchainActions
      .\/ Endpoint "set price" Integer
      .\/ Endpoint "buy tokens" Integer
      .\/ Endpoint "withdraw" (Integer, Integer)
      
